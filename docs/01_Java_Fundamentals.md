# Class-1 Agenda

- Introduction to Java
- Java Features
- Fundamentals of Java
- Basic Syntax and Control Structure
- Why use Java?
- ~Exception Handling in Java~
- Live Coding

### Low Level Language

- A language that has more resemblance towards machine
- Platform dependent \(Machine Language for Mac will be different from Window\)

### High Level language

- A language that is human readable
- A language that provides a layer between machine and you such that with few changes you will be able to achieve same objective on different machines.

### What is Java?

Java is a high-level, class-based, object-oriented programming language designed to have as few implementation dependencies as possible.

- Created by `Sun Microsystems`, now owned by `Oracle`.
- Known for its "**write once, run anywhere**" capability due to its platform-independent `bytecode`.

### Features Of Java

- Simple: It’s a language that you can easily understand by reading
- Object Oriented: Every entity in Java is treated as Object
- Platform Independent: Write once and run anywhere
- Robust and secure: No one can inject random code and execute it \(because of JVM\)
- Multi-threaded: Parallel processing
- High performance
- Distributed: You can build Distributed system

### Why Java ?

- Platform Independence
- Scalability and Performance
- Enterprise-Ready: You can get running within few minutes
- Community Support: Largely used so you can find your issue

### Where to use Java ?

- CPU intensive applications
    - Any sort of processing
    - Image processing

### Key difference of Java vs Node Js

| **Aspect** | **Java** | **NodeJs** |
| --- | --- | --- |
| Paradigm | Object-oriented | Event-Driven |
| Concurrency Model | Multi-threaded |  Single Threaded, non blocking IO |
| Performance  | High for CPU intensive tasks | High for IO bound tasks |
| Use cases |  Used in enterprise applications,Android development, large systems | Ideal for real-time web applications, microservices, SPAs |
| Development speed | Slow, lot of boilerplate code | Faster, lesser boilerplate code |
| Syntax | Static typing, verbose  | Dynamic typing, concise |

## Java Fundamentals

### JDK \(Java Development Kit\)

- includes tools for developing Java applications.
- Compiler \(`javac`\), `Javadoc`, Java debugger.
- JDK is always platform dependent, what comes inside JDK makes Java platform independent
- Developer tools \+ JRE
- JRE is a part of JDK

### JRE \(Java Runtime Environment\):

- Provides the runtime environment for Java applications.
- Includes JVM, core libraries, and runtime environment to execute Java byte code.
- All imports are coming from JRE
- JVM is a part of JRE

### JVM \(Java Virtual Machine\)

- Executes Java byte code.
- Provides platform independence by running byte code on different platforms.
- JVM is platform dependent

### Byte Code

- Intermediate representation of Java source code.
- Generated by the Java compiler \(`javac`\).

### Platform Independence

- Java byte code is platform-independent.
- It can be executed on any system with a compatible JVM.

![](https://whimuc.com/XhDvKC3gTinJ3qS7MQym7i/4PpSZmB1qnbpD7.png)
### JDK Components

![](https://whimuc.com/XhDvKC3gTinJ3qS7MQym7i/3vrwLczmRvGoUJ.png)
## JVM Components

![](https://whimuc.com/XhDvKC3gTinJ3qS7MQym7i/AxhUDRmNETD94G.png)
The JVM is responsible for running Java byte code, which is platform-independent code compiled from Java source code.

### The JVM includes:

- **Class Loader:** Loads Java classes into memory.
- **Byte code Verifier**: Ensures the bytecode is valid and doesn't violate Java security constraints
- **Interpreter:** Converts bytecode into machine code at runtime \(though modern JVMs often use Just-In-Time \(JIT\) compilation for better performance\).
- **JIT Compiler**: Compiles bytecode to native machine code at runtime, improving performance.
- **Garbage Collector:** Manages memory by automatically reclaiming memory that is no longer in use
- **Runtime**: Provides necessary libraries and other components needed to run Java programs.

Almost correct\! Let me clarify and refine your understanding of JVM memory areas:

## JVM Memory Areas

1. **Method Area**
    - **Stores**:
        - Class metadata \(not the compiled code itself\)
        - Runtime constant pool
        - Field & method data
        - Method & constructor code
        - Special methods \(initializers\)
    - **Note**: Called "Metaspace" in modern JVMs \(since Java 8\)
    - **Shared** among all threads
2. **Heap**
    - **Stores**: All object instances and arrays
    - **Divided** into:
        - Young Generation \(Eden \+ Survivor spaces\)
        - Old Generation \(Tenured space\)
    - **Managed** by garbage collector
3. **JVM Stacks**
    - **Per-thread** memory area \(each thread has its own stack\)
    - **Stores**:
        - Stack frames for each method call
        - Local variables
        - Partial results
        - Method return values
    - **Note**: Often called "Java Stacks" to distinguish from Native Method Stacks
4. **PC Registers** \(Program Counter\)
    - **Stores**: Address of the current JVM instruction being executed
    - **Per-thread**: Each thread has its own PC register
    - **Note**: For native methods, PC register is undefined
5. **Native Method Stacks**
    - **Per-thread** memory area
    - **Stores**: Native method calls \(typically C/C\+\+ code via JNI\)
    - **Note**: Separate from Java Stacks because native code has different memory requirements

### Visual Representation:

```
JVM Memory
├── Method Area \(Metaspace\) \[Shared\]
├── Heap \[Shared\]
│   ├── Young Generation
│   └── Old Generation
├── Thread-specific Areas
│   ├── PC Register \(per thread\)
│   ├── JVM Stack \(per thread\)
│   └── Native Method Stack \(per thread\)
└── \(Optional\) Native Memory
    ├── Direct Buffers
    └── Memory-mapped files
```
This is the standard JVM memory model as specified in the JVM specification.

## JVM End To End Architecture

![](https://whimuc.com/XhDvKC3gTinJ3qS7MQym7i/9C6fPaajocs4FR.png)
### JVM Execution Process

- **Loading**: The class loader subsystem loads the .class files.
- **Linking**:
    - **Verification**: The bytecode Verifier checks the code.
    - **Preparation**: Allocates memory for class variables and initializes them to default values.
    - **Resolution**: Resolves symbolic references in the class files to actual references.
- **Initialization**: Initializes class variables to their defined values and executes static initializers.
- **Execution**: The execution engine interprets or compiles the bytecode into native code and executes it.

### JIT vs Interpreter

**Interpreter:**

- **Function**: Executes Java bytecode one instruction at a time.
- **Performance**: Slower execution due to repetitive translation.
- **Memory Usage**: Lower memory usage; no storage of compiled code.
- **Startup Time**: Quick, no initial compilation overhead.
- **Use Case**: Ideal for quickly starting execution and handling rarely used code paths.

**JIT Compiler:**

- **Function**: Compiles Java bytecode to native machine code at runtime.
- **Performance**: Faster execution after initial compilation; applies optimizations.
- **Memory Usage**: Higher memory usage; stores compiled machine code.
- **Startup Time**: Slower due to compilation overhead, but faster subsequent execution.
- **Use Case**: Best for frequently executed code paths \(hot spots\) for long-term performance gains.

### Java Compaction Process

![](https://whimuc.com/XhDvKC3gTinJ3qS7MQym7i/2AjrESvynmpCU8.png)
**Compaction**

- Compilation is the process of converting the Java source code into an executable form, known as bytecode.
- The Java compiler takes the source code and produces bytecode, which is then executed by the Java Virtual Machine \(JVM\).
- The code cannot be compiled because of compilation errors.
- Compared to interpreted compiled programs operate faster.

**Interpretation**

- Interpretation is the process of executing the Java bytecode directly by the JVM.
- The bytecode is loaded into the JVM, and the JVM interprets the bytecode and executes the program.
- Debugging is mainly done in run-time.
- When an interpreted program executes, changes can be made.

**Compaction vs Interpretation**

- Compilation converts source code into bytecode, whereas interpretation executes bytecode directly by the JVM.
- The compilation is done once during the development process, while interpretation happens each time the program is run.
- Compilation allows for the optimization of the code, while interpretation provides greater flexibility and dynamic behavior.
- Overall, both compilation and interpretation play important roles in Java programming, and the choice of which to use will depend on the specific needs of the program.

## Java essentials

- Primitive data types, non primitive data types
- Variables, scope of the variables, and operators
- Control statements - If, If else, switch
- Looping statements

### Data Types

![](https://whimuc.com/XhDvKC3gTinJ3qS7MQym7i/3318n1avk9TAW7.png)
### Java Operators

![](https://whimuc.com/XhDvKC3gTinJ3qS7MQym7i/2qZvoPHgLY4zG5.png)
Commands

```
Javap -c <<Test.class>>
Java -verbose:class <<Test.class>>
Jps -l
Jcmd <pid> <<Flags>>
```

